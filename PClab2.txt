Write a OpenMP program to sort an array on n elements using both sequential and parallel
mergesort(using Section). Record the difference in execution time.
#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <time.h>
#define SIZE 100000
void merge(int arr[], int left, int mid, int right)
{
int i, j, k;
int n1 = mid - left + 1;
int n2 = right - mid;
int *L = (int *)malloc(n1 * sizeof(int));
int *R = (int *)malloc(n2 * sizeof(int));
for (i = 0; i< n1; i++)
L[i] = arr[left + i];
for (j = 0; j < n2; j++)
R[j] = arr[mid + 1 + j];
i = 0; j = 0; k = left;
while (i< n1 && j < n2)
arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
while (i< n1)
arr[k++] = L[i++];
while (j < n2)
arr[k++] = R[j++];
free(L);
free(R);
}
void serialMergeSort(int arr[], int left, int right)
{
if (left < right)
{
int mid = left + (right-left)/2;
serialMergeSort(arr, left,mid);
serialMergeSort(arr, mid + 1, right);
merge(arr, left, mid, right);
}
}
void parallelMergeSort(int arr[], int left, int right, int depth)
{
if (left < right)
{
int mid = left + (right-left)/2;
if (depth <= 4)
{
#pragma omp parallel sections
{
#pragma omp section
parallelMergeSort(arr, left, mid, depth + 1);
#pragma omp section
parallelMergeSort(arr, mid + 1,right,depth+1);
}
}
else
{
// Switch to serial to avoid too many threads
serialMergeSort(arr, left, mid);
serialMergeSort(arr, mid + 1, right);
}
merge(arr, left, mid, right);
}
}
int main()
{
int *arr_serial = (int *)malloc(SIZE * sizeof(int));
int *arr_parallel = (int *)malloc(SIZE * sizeof(int));
for (int i = 0; i< SIZE; i++)
{
int val = rand() % 100000;
arr_serial[i] = val;
arr_parallel[i] = val;
}
clock_t start_serial = clock();
serialMergeSort(arr_serial, 0, SIZE -1);
clock_t end_serial = clock();
double time_serial = (double)(end_serial-start_serial) / CLOCKS_PER_SEC;
clock_t start_parallel = clock();
parallelMergeSort(arr_parallel, 0, SIZE - 1, 0);
clock_t end_parallel = clock();
double time_parallel = (double)(end_parallel - start_parallel) / CLOCKS_PER_SEC;
printf("Serial Merge Sort Time : %.6f seconds\n", time_serial);
printf("Parallel Merge Sort Time : %.6f seconds\n", time_parallel);
for (int i = 0; i< SIZE; i++)
{
if (arr_serial[i] != arr_parallel[i])
{
printf("Mismatch at index %d\n",i);
break;
}
}
free(arr_serial);
free(arr_parallel);
return 0;
}
-----------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <time.h>

#define SIZE 100000

// Merge function
void merge(int arr[], int temp[], int left, int mid, int right) {
    int i = left, j = mid + 1, k = left;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }

    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];

    for (i = left; i <= right; i++)
        arr[i] = temp[i];
}

// Serial merge sort
void serialMergeSort(int arr[], int temp[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        serialMergeSort(arr, temp, left, mid);
        serialMergeSort(arr, temp, mid + 1, right);
        merge(arr, temp, left, mid, right);
    }
}

// Parallel merge sort using OpenMP tasks
void parallelMergeSort(int arr[], int temp[], int left, int right, int depth) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        if (depth < 4) { // Limit recursion depth for tasks
            #pragma omp task shared(arr, temp)
            parallelMergeSort(arr, temp, left, mid, depth + 1);

            #pragma omp task shared(arr, temp)
            parallelMergeSort(arr, temp, mid + 1, right, depth + 1);

            #pragma omp taskwait
        } else {
            serialMergeSort(arr, temp, left, mid);
            serialMergeSort(arr, temp, mid + 1, right);
        }
        merge(arr, temp, left, mid, right);
    }
}

int main() {
    int *arr_serial = (int *)malloc(SIZE * sizeof(int));
    int *arr_parallel = (int *)malloc(SIZE * sizeof(int));
    int *temp_serial = (int *)malloc(SIZE * sizeof(int));
    int *temp_parallel = (int *)malloc(SIZE * sizeof(int));

    srand(time(NULL)); // Seed random numbers
    for (int i = 0; i < SIZE; i++) {
        int val = rand() % 100000;
        arr_serial[i] = val;
        arr_parallel[i] = val;
    }

    // Serial timing
    double start_serial = omp_get_wtime();
    serialMergeSort(arr_serial, temp_serial, 0, SIZE - 1);
    double end_serial = omp_get_wtime();
    double time_serial = end_serial - start_serial;

    // Parallel timing
    double start_parallel = omp_get_wtime();
    #pragma omp parallel
    {
        #pragma omp single
        parallelMergeSort(arr_parallel, temp_parallel, 0, SIZE - 1, 0);
    }
    double end_parallel = omp_get_wtime();
    double time_parallel = end_parallel - start_parallel;

    // Results
    printf("Serial Merge Sort Time   : %.6f seconds\n", time_serial);
    printf("Parallel Merge Sort Time : %.6f seconds\n", time_parallel);

    // Verification
    for (int i = 0; i < SIZE; i++) {
        if (arr_serial[i] != arr_parallel[i]) {
            printf("Mismatch at index %d\n", i);
            break;
        }
    }

    free(arr_serial);
    free(arr_parallel);
    free(temp_serial);
    free(temp_parallel);

    return 0;
}
